# Memo (Memento mori)

Основа работы со своим временем -- приоретизация задач. Сложность в том, что на разных дистанциях планирования размеры задач и их приоритеты различаются. А так же нужно помнить, что физические ресурсы ограничены и, будем честны, половина планов пойдёт наперекосяк. Нужно написать приложение, амортизирующее эти сложности и имплементирующее в себе некоторые best practices, которые помогут в задаче планирования и, как следствие, в работе.

## Дробление задач и приоритизация

Приложение состоит из нескольких уровней по одному на каждый горизонт планирования -- дистанцию (семестр, месяц, неделя, день, либо пользовательская кастомизация). На каждом держим задачи определённого нормированного размера (например, не больше дистанции следующего уровня: на недельном не больше дня), чтобы их можно было соотносить друг с другом и заниматься приоретизированием на этом уровне.

Каждый уровень имеет несколько списков на текущую дистанцию и несколько дистанций вперёд. Например, на недельном уровне: эта неделя, следующая, послеследующая. В каждом списке задачи расположены в порядке приоритета. Так же ведутся списки сделанных задач за предыдущие дистанции.
Верхние уровни дополнительно имеют ещё один список -- backlog задач.

Каждая задача имеет: заголовок, описание, дедлайн, примерное время на решение, тег по Эйзенхауэру, таски-пререквизиты. Так же с каждой задачей отображается её иерархия по уровням: например, Преподавание / Haskell ITMO / Составить дз 8. Иерархия служит дополнению контекста, по "Составить дз 8" смысл задачи ещё не понятен.

По сути иерархия уровней представляет собой иерархию матриц Эйзенхауэра -- по одной на дистанцию.

Задача может иметь компоненты -- виртуальные задачи. Они служат дополнению контекста и при этом явно не присутствуют на уровне (логически относятся к уровню родительской задачи), не захламляя его. 
Наример: задача уровня год — диплом, у неё виртуальные задачи (компоненты) -- спека, дока, прототип, текст, анализ решений.
Таким образом, держим контекст: Диплом / Спека (виртуальная, нет на уровне) / Изучить спеку котлина / Прочитать главу с типами.

## Best practices

1. Нужно не забывать про поддержание себя в работоспособном состоянии, поэтому на верхнем уровне есть не удаляемая задача self care. И на каждом следующем уровне мы решаем, как будем обеспечивать работоспособность на дистанции. В заполнении это штуки требуется честность (иначе плохое состояние и прокрастинация), поэтому приложение будет постоянно напоминать расставлять наследников этой задачи на уровни (и на уровне дня наследник должен быть всегда).
2. Планированием нужно заниматься в определённое время (думай медленно, решай быстро). Поэтому на каждой дистанции автоматически заводятся задачи на планирование следующей дистанции. 
3. На уровне дня задачи должны быть в формате ЭКД, постоянно напоминаем об этом пользователю.
4. Работа происходит так: входим в рабочее состояние на маленьких задачках, дальше в состоянии потока делаем большие задачи с нетривиальным контекстом. Поэтому на уровне дня имеем не просто список, а секции такого вида: задачка на разогрев, задачка в поток.

## Дополнительно

1) Зная дедлайны задач и ожидаемое время выполнения (можно вывести по уровню), можно показывать, сколько пользователь сейчас должен тратить времени в день, чтобы успеть. Это нужно чтобы вовремя забивать (делегировать) неважные задачи. Если больше половины рабочего дня -- аларм.
2) Поддержка техники помидор.
3) Интеграция с гуглокалендарём и автоматические задачи с ивентами.
